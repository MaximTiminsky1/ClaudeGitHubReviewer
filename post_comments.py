import argparse
import json
import os
import re
import subprocess
import sys
from pathlib import Path
from typing import List, Dict, Any


def load_env():
    env_path = Path(__file__).parent / '.env'
    if env_path.exists():
        with open(env_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    os.environ[key.strip()] = value.strip()

load_env()


class GitHubCommentPoster:
    def __init__(self, review_file: str):
        self.review_file = Path(review_file)

        if not self.review_file.exists():
            raise FileNotFoundError(f"File not found: {review_file}")

        self.metadata = None
        self.comments = []

    def parse_review_file(self) -> Dict[str, Any]:
        print(f"üìñ Read the file: {self.review_file}")

        with open(self.review_file, 'r', encoding='utf-8') as f:
            content = f.read()

        metadata_match = re.search(
            r'<!-- REVIEW_METADATA\n(.*?)\n-->',
            content,
            re.DOTALL
        )

        if not metadata_match:
            raise ValueError("Metadata not found in the file. The file must be generated by the /review-pr.md.")

        metadata = json.loads(metadata_match.group(1))

        print(f"‚úÖ Comments found: {len(metadata.get('comments', []))}")
        print(f"   PR: {metadata.get('owner')}/{metadata.get('repo')}#{metadata.get('pr_number')}")

        return metadata

    def preview_comments(self, metadata: Dict[str, Any]):
        comments = metadata.get('comments', [])

        if not comments:
            print("\n‚ö†Ô∏è  No comments to publish.")
            return

        print("\n" + "="*60)
        print("üìã COMMENTS PREVIEW")
        print("="*60 + "\n")

        for i, comment in enumerate(comments, 1):
            severity_emoji = {
                'critical': 'üî¥ CRITICAL',
                'warning': '‚ö†Ô∏è  WARNING',
                'suggestion': 'üí° SUGGESTION'
            }.get(comment['severity'], 'üí¨ COMMENT')

            print(f"{i}. {severity_emoji}")
            print(f"   File: {comment['path']}:{comment['line']}")
            print(f"   Text: {comment['body'][:100]}...")
            print()

    def confirm_posting(self) -> bool:
        print("="*60)
        response = input("Publish these comments to GitHub? (yes/no): ").strip().lower()
        return response in ['yes', 'y']

    def post_comments(self, metadata: Dict[str, Any]) -> bool:
        owner = metadata['owner']
        repo = metadata['repo']
        pr_number = metadata['pr_number']
        comments = metadata['comments']

        if not comments:
            print("‚úÖ  No comments to publish.")
            return True

        print(f"\nüì§ Publishing {len(comments)} comments to GitHub...\n")

        # Get the latest commit SHA from the PR
        try:
            cmd = ["gh", "api", f"repos/{owner}/{repo}/pulls/{pr_number}"]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            pr_data = json.loads(result.stdout)
            commit_id = pr_data['head']['sha']
            print(f"üìå Using commit: {commit_id[:8]}")
        except Exception as e:
            print(f"‚ö†Ô∏è  Could not get PR commit SHA: {e}")
            print("üîÑ Falling back to individual comments...")
            return self._post_comments_individually(owner, repo, pr_number, comments)

        review_comments = []
        for comment in comments:
            review_comments.append({
                "path": comment["path"],
                "line": comment["line"],
                "body": comment["body"]
            })

        review_data = {
            "body": "ü§ñ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π Code Review",
            "event": "COMMENT",
            "commit_id": commit_id,
            "comments": review_comments
        }

        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False, encoding='utf-8') as tmp:
            json.dump(review_data, tmp, ensure_ascii=False, indent=2)
            tmp_path = tmp.name

        try:
            cmd = [
                "gh", "api",
                f"repos/{owner}/{repo}/pulls/{pr_number}/reviews",
                "--method", "POST",
                "--input", tmp_path
            ]

            result = subprocess.run(cmd, capture_output=True, text=True, check=True)

            print("‚úÖ Comments successfully published!")
            print(f"üîó View: https://github.com/{owner}/{repo}/pull/{pr_number}")

            return True

        except subprocess.CalledProcessError as e:
            print(f"\n‚ùå Error while publishing comments:")
            print(f"   {e.stderr}")
            print(f"\nüí° Tip: Make sure line numbers are correct (should be file lines, not diff lines)")
            print(f"   Check the diff and verify line numbers match the actual file content.")
            return False

        finally:
            Path(tmp_path).unlink(missing_ok=True)

    def run(self, auto_confirm: bool = False):
        print(f"üöÄ Starting comment publishing\n")

        try:
            metadata = self.parse_review_file()
        except Exception as e:
            print(f"‚ùå Error reading file: {e}")
            return False

        self.preview_comments(metadata)

        if not auto_confirm and not self.confirm_posting():
            print("\n‚ùå Publishing cancelled")
            return False

        success = self.post_comments(metadata)

        if success:
            print("\n" + "="*60)
            print("‚úÖ ALL COMMENTS HAVE BEEN PUBLISHED!")
            print("="*60)
        else:
            print("\n‚ö†Ô∏è  Some comments were not published")

        return success


def main():
    parser = argparse.ArgumentParser(
        description="GitHub PR Comment Poster - publishes comments to GitHub"
    )
    parser.add_argument(
        "review_file",
        help="Path to the review markdown file (generated by review_pr.py)"
    )
    parser.add_argument(
        "-y", "--yes",
        action="store_true",
        help="Automatically confirm publishing (skip the confirmation prompt)"
    )

    args = parser.parse_args()

    try:
        poster = GitHubCommentPoster(args.review_file)
        success = poster.run(auto_confirm=args.yes)
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"\n‚ùå Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
